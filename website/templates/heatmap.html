<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v4.js"></script>

<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">



<div class="w3-container" id="word_vector_explanation">
  <div class="w3-content" style="max-width:1000px">
    <h5 class="w3-padding-16"><span class="w3-tag w3-wide">Word Vectors</span></h5>
    <p>In Natural Language Processing (or NLP), a word vector is a mathematical representation of a word's meaning. A word vector is made up of an arbitrary number of dimensions, where each dimension represents some semantic quality of the word. A word is assigned a value in each of these dimensions, creating the word vector. This approach allows for two word vectors to be quantitatively examined for how similar they are to each other, semantically speaking. For example, in a given set of word vectors, imagine that the word vectors for King and Queen are much closer in value than the word vector for apple. We can conclude that King and Queen have some semantic similarities (they are titles, terms for royalty, references to people, etc.) which apple does not.</p>
    <p>Word vectors are generated by NLP models, which take a corpus of text as an input and output a list of word vectors for each unique word in the corpus. These models are boradly referred to as Word2Vec. The specific implementation used in this research is a shallow neural network trained by an algorithm known as skip-gram, which is used to determine the most related words to a certain word. Given the initial corpus of text and a number of dimensions, Word2Vec generates values for each word for each dimensions and outputs the aforementioned list.</p>
    <p>As word vectors are vectors, they can be compared to each other by calculating their cosine similarity. Cosine similarity measure how closely two vectors point towards each other, on a scale from -1 to 1; a value of -1 means they point in opposite directions, 0 means they are orthagonal, and 1 means they point in the same directions. Cosine similarity can be calculated regardless of the number of dimensions a vector has, meaning that they are a useful way to visualize the relationship between word vectors which generally have 100 or more dimensions assigend to them.</p>
    <h5 class="w3-padding-16"><span class="w3-tag w3-wide">Changing Meanings</span></h5>
    <p>The word vectors that Word2Vec outputs will change based on the corpus of text that is inputted. Thus, by carefully selecting what text to use, we can compare the differences in word vectors generated from different corpuses, and draw conclusions as to why. This is an intruiging tool to study something such as history; by dividing text into distinct time periods and creating models from them, we can observe how words change in their associations to eachother over time.</p>
    <p>For this particular research, we are focusing on perceptions of Soviet Premier Josef Stalin. By taking the name Stalin and calculating its cosine similarity with select other words, we can see how their associations changed during the course of the Second World War and the beginning of the Cold War.</p>
  
  </div>
  <div class="w3-padding-32"></div>
</div>

<div class="w3-twothird w3-container" id="my_dataviz"></div>
<div class="w3-third w3-container" id = "info">
  <h3>August 23rd, 1939 - June 22nd, 1941</h3>
  <p>From the official signing of the Molotov-Ribbontrop Pact, to the first day of Operation Barbarossa, the German invasion of the Soviet Union.</p>
  <h3>June 23rd, 1941 - February 2nd, 1943</h3>
  <p>From Operation Barbarossa to the Soviet announcement of the surrender of the German Sixth Army in Stalingrad.</p>
  <h3>February 3rd, 1943 - May 9th, 1945</h3>
  <p>From the end of the Battle of Stalingrad to the official surrender of Germany in Soviet historiography.</p>
  <h3>May 10th, 1945 - June 24th, 1948</h3>
  <p>From the end of the war in Europe to the beginning of the Soviet blockade of Berlin.</p>
  <h3>June 25th, 1948 - March 5th, 1953</h3>
  <p>From the Berlin Blockade to the death of Stalin.</p>
</div>

<!-- Load color palettes -->
<script src="https://github.com/d3/d3-scale-chromatic/blob/main/src/diverging/RdBu.js"></script>

<script>

    // set the dimensions and margins of the graph
    var margin = {top: 80, right: 25, bottom: 30, left: 150},
      width = 850 - margin.left - margin.right,
      height = 700 - margin.top - margin.bottom;
    
    // append the svg object to the body of the page
    var svg = d3.select("#my_dataviz")
    .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");
    
    //Read the data
    d3.csv("static/heatmap.csv", function(data) {
    
      // Labels of row and columns -> unique identifier of the column called 'group' and 'variable'
      var myGroups = d3.map(data, function(d){return d.word;}).keys()
      var myVars = d3.map(data, function(d){return d.period;}).keys()
    
      // Build X scales and axis:
      var x = d3.scaleBand()
        .range([ 0, width ])
        .domain(myGroups)
        .padding(0.05);
      svg.append("g")
        .style("font-size", 15)
        .attr("transform", "translate(0," +'-12'+ ")")
        .call(d3.axisBottom(x).tickSize(0))
        .select(".domain").remove()
    
      // Build Y scales and axis:
      var y = d3.scaleBand()
        .range([ height, 0 ])
        .domain(myVars)
        .padding(0.05);
      svg.append("g")
        .style("font-size", 15)
        .call(d3.axisLeft(y).tickSize(0))
        .select(".domain").remove()

      // Build color scale
      var myColor = d3.scaleSequential()
        .interpolator(d3.interpolate("white", "red"))
        .domain([0,.65])
    
      // create a tooltip
      var tooltip = d3.select("#my_dataviz")
        .append("div")
        //.call(d3.axisRight(y).tickSize(0))
        .style("opacity", 0)
        .attr("class", "tooltip")
        .style("background-color", "white")
        .style("border", "solid")
        .style("border-width", "2px")
        .style("border-radius", "5px")
        .style("padding", "5px")
    
      // Three function that change the tooltip when user hover / move / leave a cell
      var mouseover = function(d) {
        tooltip
          .style("opacity", 1)
        d3.select(this)
          .style("stroke", "black")
          .style("opacity", 1)
      }
      var mousemove = function(d) {
        tooltip
          .style("left", (d3.mouse(this)[0]+70) + "px")
          .style("top", (d3.mouse(this)[1]) + "px")
          .html("The cosine similarity of Stalin and <b>" + this.id + "</b> is <b>" + d.value + "</b> for the period <b>" + d.period + "</b>.")
          //.attr("x", 0)
          //.attr("y", -550)
      }
      var mouseleave = function(d) {
        tooltip
          .style("opacity", 0)
        d3.select(this)
          .style("stroke", "none")
          .style("opacity", 0.8)
      }
    
      // add the squares
      var n = 0
      svg.selectAll()
        .data(data, function(d) {return d.word+':'+d.period;})
        .enter()
        .append("rect")
          .attr("x", function(d) { return x(d.word) })
          .attr("y", function(d) { return y(d.period) })
          .attr("rx", 4)
          .attr("ry", 4)
          .attr("width", x.bandwidth() )
          .attr("height", y.bandwidth() )
          .style("fill", function(d) { return myColor(d.value)} )
          .style("stroke-width", 4)
          .style("stroke", "none")
          .style("opacity", 0.8)
          .attr("id", function(d) {return d.word;})
        .on("mouseover", mouseover)
        .on("mousemove", mousemove)
        .on("mouseleave", mouseleave)

      svg.append("text")
        .attr("x", width)
        .attr("y", d[0].period)
        .text("test")
    })
    
    // Add title to graph
    svg.append("text")
            .attr("x", 0)
            .attr("y", -50)
            .attr("text-anchor", "left")
            .style("font-size", "30px")
            .text("Associations with Stalin");
    
    // Add subtitle to graph
    svg.append("text")
            .attr("x", 0)
            .attr("y", -30)
            .attr("text-anchor", "left")
            .style("font-size", "14px")
            .style("fill", "grey")
            .style("max-width", 400)
            .text("Hover over each cell to see exact values");
    
    
    </script>


<div class="w3-container" id="metadata_explanation">
  <div class="w3-content" style="max-width:1000px">
    <h5 class="w3-padding-16"><span class="w3-tag w3-wide">Word Vectors</span></h5>
    <p>In Natural Language Processing (or NLP), a word vector is a mathematical representation of a word's meaning. A word vector is made up of an arbitrary number of dimensions, where each dimension represents some semantic quality of the word. A word is assigned a value in each of these dimensions, creating the word vector. This approach allows for two word vectors to be quantitatively examined for how similar they are to each other, semantically speaking. For example, in a given set of word vectors, imagine that the word vectors for King and Queen are much closer in value than the word vector for apple. We can conclude that King and Queen have some semantic similarities (they are titles, terms for royalty, references to people, etc.) which apple does not.</p>
    <p>Word vectors are generated by NLP models, which take a corpus of text as an input and output a list of word vectors for each unique word in the corpus. These models are boradly referred to as Word2Vec. The specific implementation used in this research is a shallow neural network trained by an algorithm known as skip-gram, which is used to determine the most related words to a certain word. Given the initial corpus of text and a number of dimensions, Word2Vec generates values for each word for each dimensions and outputs the aforementioned list.</p>
    <p>As word vectors are vectors, they can be compared to each other by calculating their cosine similarity. Cosine similarity measure how closely two vectors point towards each other, on a scale from -1 to 1; a value of -1 means they point in opposite directions, 0 means they are orthagonal, and 1 means they point in the same directions. Cosine similarity can be calculated regardless of the number of dimensions a vector has, meaning that they are a useful way to visualize the relationship between word vectors which generally have 100 or more dimensions assigend to them.</p>
    <h5 class="w3-padding-16"><span class="w3-tag w3-wide">Changing Meanings</span></h5>
    <p>The word vectors that Word2Vec outputs will change based on the corpus of text that is inputted. Thus, by carefully selecting what text to use, we can compare the differences in word vectors generated from different corpuses, and draw conclusions as to why. This is an intruiging tool to study something such as history; by dividing text into distinct time periods and creating models from them, we can observe how words change in their associations to eachother over time.</p>
    <p>For this particular research, we are focusing on perceptions of Soviet Premier Josef Stalin. By taking the name Stalin and calculating its cosine similarity with select other words, we can see how their associations changed during the course of the Second World War and the beginning of the Cold War.</p>
  
  </div>
  <div class="w3-padding-32"></div>
</div>

<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>

<!-- Create an element where the map will take place -->
<div id="my_dataviz2"></div>

<style>
.circle:hover{
  stroke: black;
  stroke-width: 4px;
}
</style>

<script>

    // Size ?
    var width = 1000
    var height = 600
    
    // The svg
    var svg2 = d3.select("#my_dataviz2")
      .append("svg")
      .attr("width", width)
      .attr("height", height)
    
    // Map and projection
    var projection = d3.geoMercator()
        .center([-95, 38])                // GPS of location to zoom on
        .scale(700)                       // This is like the zoom
        .translate([ width/2, height/2 ])


    
    // Load external data and boot
    d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson", function(data){
    
        // Filter data
        data.features = data.features.filter( function(d){return d.properties.name=="USA"} )

        svg2.append("g")
            .selectAll("path")
            .data(data.features)
            .enter()
            .append("path")
              .attr("fill", "#b8b8b8")
              .attr("d", d3.geoPath()
                  .projection(projection)
              )
            .style("stroke", "black")
            .style("opacity", .3)


        d3.csv("static/GeoData.csv", function(geodata) {
            //var lat = d3.map(geodata, function(d){return +d.lat;})
            //var long = d3.map(geodata, function(d){return +d.long;})
            var name = d3.map(geodata, function(d){return d.name;}).keys()
            //var size = d3.map(geodata, function(d){return +d.freq;})

            
            var size = d3.scaleLinear()
                .domain([1,7000])  // What's in the data
                .range([ 2, 50])  // Size in pixel
            // Draw the map
        
            // create a tooltip
            var Tooltip = d3.select("#my_dataviz2")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 1)
            .style("background-color", "white")
            .style("border", "solid")
            .style("border-width", "2px")
            .style("border-radius", "5px")
            .style("padding", "5px")
        
            // Three function that change the tooltip when user hover / move / leave a cell
            var mouseover = function(d) {
            Tooltip.style("opacity", 1)
            }
            var mousemove = function(d) {
            Tooltip
                .html(d.name + ": " + d.size + " pages.")
                .style("left", (d3.mouse(this)[0]+10) + "px")
                .style("top", (d3.mouse(this)[1]) + "px")
            }
            var mouseleave = function(d) {
            Tooltip.style("opacity", 0)
            }
        
            // Add circles:
            svg2
            .selectAll("myCircles")
            .data(geodata)
            .enter()
            .append("circle")
                .attr("cx", function(d){ return projection([+d.long, +d.lat])[0] })
                .attr("cy", function(d){ return projection([+d.long, +d.lat])[1] })
                .attr("r", function(d){ return size(+d.freq) })
                .attr("class", "circle")
                .style("fill", "red")
                .attr("stroke", "#red")
                .attr("stroke-width", 3)
                .attr("fill-opacity", .4)
            .on("mouseover", mouseover)
            .on("mousemove", mousemove)
            .on("mouseleave", mouseleave)
        })
    })
    
    </script>
